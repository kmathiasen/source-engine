// ###################### GLOBALS ######################

new bool:g_bIsDownloading;

new Handle:g_hHost = INVALID_HANDLE;
new Handle:g_hAutoUpdateHost = INVALID_HANDLE;
new Handle:g_hHostPath = INVALID_HANDLE;

new Handle:g_hModelPaths = INVALID_HANDLE;
new Handle:g_hModelArrays = INVALID_HANDLE;
new Handle:g_hErrorDownloading = INVALID_HANDLE;

new String:g_sDownloadPath[PLATFORM_MAX_PATH];

new String:g_sHost[LEN_NAMES] = "hgitems.hellsgamers.com";
new String:g_sAutoUpdateHost[LEN_NAMES] = "fastdl.hellsgamers.com";
new String:g_sHostPath[LEN_NAMES] = "/pd/";

// ###################### EVENTS ######################


stock Downloads_OnPluginStart()
{
    BuildPath(Path_SM,
              g_sDownloadPath, sizeof(g_sDownloadPath),
              "data/hg_items_dynamic_downloads.txt");

    g_hErrorDownloading = CreateArray(ByteCountToCells(PLATFORM_MAX_PATH));
    g_hModelPaths = CreateArray(ByteCountToCells(PLATFORM_MAX_PATH));
    g_hModelArrays = CreateTrie();

    g_hHost = CreateConVar("hg_premium_download_host",
                           "hgitems.hellsgamers.com",
                           "The download host to auto download files from");

    g_hAutoUpdateHost = CreateConVar("hg_premium_autoupdate_host",
                                     "fastdl.hellsgamers.com",
                                     "The download host to auto update this mod from");

    g_hHostPath = CreateConVar("hg_premium_download_path", "/pd/",
                               "The path after the host to download the files from");

    HookConVarChange(g_hHost, Downloads_OnConVarChanged);
    HookConVarChange(g_hHostPath, Downloads_OnConVarChanged);

    CreateTimer(5.0, Timer_UpdateSMX);
}

public Downloads_OnConVarChanged(Handle:CVar, const String:oldv[], const String:newv[])
{
    if (CVar == g_hHost)
        GetConVarString(g_hHost, g_sHost, sizeof(g_sHost));

    else if (CVar == g_hAutoUpdateHost)
        GetConVarString(g_hAutoUpdateHost, g_sAutoUpdateHost, sizeof(g_sAutoUpdateHost));

    else if (CVar == g_hHostPath)
        GetConVarString(g_hHostPath, g_sHostPath, sizeof(g_sHostPath));
}

stock Downloads_OnDBConnect()
{
    GetDownloads();
}

stock Downloads_OnMapStart()
{
    ReadDownloads();
}


// ###################### FUNCTIONS ######################


stock GetDownloads()
{
    decl String:query[256];
    new Handle:iFile = OpenFile(g_sDownloadPath, "w");

    WriteFileLine(iFile, "// Downloads automatically generated by HG Items");
    WriteFileLine(iFile, "// Probably shouldn't edit this");

    CloseHandle(iFile);

    for (new i = 0; i < GetArraySize(g_hModelPaths); i++)
    {
        new Handle:arr;
        decl String:model[PLATFORM_MAX_PATH];

        GetArrayString(g_hModelPaths, i, model, sizeof(model));
        if (GetTrieValue(g_hModelArrays, model, arr))
            CloseHandle(arr);
    }

    ClearArray(g_hModelPaths);
    ClearTrie(g_hModelArrays);

    Format(query, sizeof(query),
           "SELECT i.filepath, d.filepath FROM items i JOIN downloads d ON i.id = d.itemid WHERE (i.filepath != '') and (i.servertype & %d) and (i.servertype > 0)",
           g_iServerType);

    SQL_TQuery(g_hDbConn, GetDownloadsCallback, query);

    Format(query, sizeof(query),
           "SELECT i.filepath_ct, d.filepath FROM items i JOIN downloads d ON i.id = d.itemid WHERE (i.filepath_ct != '') and (i.servertype & %d) and (i.servertype > 0)",
           g_iServerType);

    SQL_TQuery(g_hDbConn, GetDownloadsCallback, query);
}

stock DownloadShit()
{
    if (g_bIsDownloading)
        return;

    decl Handle:arr;
    decl String:model[PLATFORM_MAX_PATH];
    decl String:download[PLATFORM_MAX_PATH];

    for (new i = 0; i < GetArraySize(g_hModelPaths); i++)
    {
        GetArrayString(g_hModelPaths, i, model, sizeof(model));
        GetTrieValue(g_hModelArrays, model, arr);

        for (new j = 0; j < GetArraySize(arr); j++)
        {
            GetArrayString(arr, j, download, sizeof(download));
            if (FindStringInArray(g_hErrorDownloading, download) != -1)
                continue;

            if (FileExists(download, true))
            {
                RemoveFromArray(arr, j--);
                continue;
            }

            DownloadFile(download, g_sHost);
            return;
        }
    }
}

stock ReadDownloads()
{
    if (!FileExists(g_sDownloadPath, true))
        return;

    new Handle:oFile = OpenFile(g_sDownloadPath, "r");
    decl String:download[PLATFORM_MAX_PATH];

    while (!IsEndOfFile(oFile))
    {
        ReadFileLine(oFile, download, sizeof(download));
        TrimString(download);

        if (!StrEqual(download, "") && strncmp(download, "//", 2))
            AddFileToDownloadsTable(download);
    }

    CloseHandle(oFile);
}

stock DownloadFile(const String:targetPath[], const String:host[], bool:update=false)
{
    // save to a .temp file, in case of corruption.
    decl String:temp[PLATFORM_MAX_PATH];
    Format(temp, sizeof(temp), "%s.temp", targetPath);

    new Handle:socket = SocketCreate(SOCKET_TCP, OnSocketError);
    new Handle:hIFile = OpenFile(temp, "wb");

    // The directory must not exist, or some shit.
    if (hIFile == INVALID_HANDLE)
    {
        new index;
        new total;

        ReplaceString(temp, sizeof(temp), "\\", "/");

        decl String:dir[PLATFORM_MAX_PATH] = "";
        decl String:add[PLATFORM_MAX_PATH];

        while ((index = SplitString(temp[total], "/", add, sizeof(add))) != -1)
        {
            total += index;
            StrCat(dir, sizeof(dir), add);

            if (StrEqual(dir, temp))
                break;

            if (!DirExists(dir))
                CreateDirectory(dir, 511);

            StrCat(dir, sizeof(dir), "/");
        }

        hIFile = OpenFile(temp, "wb");
    }

    new Handle:hData = CreateTrie();

    SetTrieValue(hData, "file handle", hIFile);
    SetTrieString(hData, "file path", temp);
    SetTrieString(hData, "host", host);

    if (update)
        SetTrieValue(hData, "old size", FileSize(targetPath));

    SocketSetArg(socket, hData);
    SocketConnect(socket, OnSocketConnected, OnSocketReceive, OnSocketDisconnected, host, 80);
}

bool:CanUseModel(client, const String:model[])
{
    new Handle:arr;
    if (!GetTrieValue(g_hModelArrays, model, arr) && FileExists(model, true))
        return true;

    PrintToChat(client,
                "%s Files for \x03%s\x04 are still being downloaded",
                MSG_PREFIX, model);

    PrintToChat(client,
                "%s You \x01should\x04 be able to use it next map",
                MSG_PREFIX);

    return false;
}


// ###################### CALLBACKS ######################


public GetDownloadsCallback(Handle:main, Handle:hndl, const String:error[], any:data)
{
    if (!CheckConnection(hndl, error))
        return;

    new Handle:iFile = OpenFile(g_sDownloadPath, "a");

    while (SQL_FetchRow(hndl))
    {
        decl String:model[PLATFORM_MAX_PATH];
        decl String:download[PLATFORM_MAX_PATH];

        SQL_FetchString(hndl, 0, model, sizeof(model));
        SQL_FetchString(hndl, 1, download, sizeof(download));

        if (FileExists(download, true))
        {
            WriteFileLine(iFile, download);
            AddFileToDownloadsTable(download);
        }

        else
        {
            new Handle:hModelArray;
            if (!GetTrieValue(g_hModelArrays, model, hModelArray))
            {
                hModelArray = CreateArray(ByteCountToCells(PLATFORM_MAX_PATH));
                PushArrayString(g_hModelPaths, model);
            }

            PushArrayString(hModelArray, download);
            SetTrieValue(g_hModelArrays, model, hModelArray);
        }
    }

    CloseHandle(iFile);
    DownloadShit();
}

public OnSocketConnected(Handle:socket, any:hData)
{
    decl String:targetPath[PLATFORM_MAX_PATH];
    decl String:request[512];
    decl String:host[LEN_NAMES];

    GetTrieString(hData, "file path", targetPath, sizeof(targetPath));
    GetTrieString(hData, "host", host, sizeof(host));

    ReplaceString(targetPath, sizeof(targetPath), ".temp", "");

    Format(request, sizeof(request),
           "GET %s%s HTTP/1.0\r\nHost: %s\r\nConnection: close\r\nAccept-Encoding: *\r\n\r\n",
           g_sHostPath, targetPath, host);

    g_bIsDownloading = true;
    SocketSend(socket, request);

    new dummy;

    if (!GetTrieValue(hData, "old size", dummy))
        PrintToChatAll("%s Started downloading \x03%s", MSG_PREFIX, targetPath);
}

public OnSocketReceive(Handle:socket, String:receiveData[], dataSize, any:hData)
{
    decl Handle:hIFile;

    new dummy;
    new index;
    new old_size;

    GetTrieValue(hData, "file handle", hIFile);
    GetTrieValue(hData, "old size", old_size);

    // Gotta get rid of those damn headers.
    if (!GetTrieValue(hData, "end headers", dummy))
    {
        if (StrContains(receiveData, "404 Not Found", false) != -1)
        {
            OnSocketError(socket, 404, 404,  hData);
            return;
        }

        if (old_size)
        {
            decl String:sLength[32];
            if (StrContains(receiveData, "Content-Length: ") > -1)
            {
                Format(sLength, sizeof(sLength), receiveData[StrContains(receiveData, "Content-Length: ") + 16]);

                for (new i = 0; i < strlen(sLength); i++)
                {
                    if (sLength[i] > '9' || sLength[i] < '0')
                        sLength[i] = '\0';
                }

                if (old_size == StringToInt(sLength))
                {
                    SocketDisconnect(socket);

                    decl String:temp[PLATFORM_MAX_PATH];
                    GetTrieString(hData, "file path", temp, sizeof(temp));

                    CloseHandle(socket);
                    CloseHandle(hData);

                    DeleteFile(temp);
                    return;
                }
            }
        }

        if (StrContains(receiveData, "\r\n\r\n") != -1)
        {
            decl String:header[dataSize];
            index = SplitString(receiveData, "\r\n\r\n", header, dataSize);

            SetTrieValue(hData, "end headers", 1);
            dataSize -= index;
        }

        else
            return;
    }

    // Write, binary style.
    WriteFile(hIFile, _:receiveData[index], dataSize / 4, 4);
    for (new i = (dataSize / 4) * 4; i < dataSize; i++)
        WriteFile(hIFile, _:receiveData[index + i], 1, 1);
}

public OnSocketDisconnected(Handle:socket, any:hData)
{
    decl String:filePath[PLATFORM_MAX_PATH];
    GetTrieString(hData, "file path", filePath, sizeof(filePath));

    decl String:newPath[PLATFORM_MAX_PATH];
    SplitString(filePath, ".temp", newPath, sizeof(newPath));

    decl Handle:hIFile;
    GetTrieValue(hData, "file handle", hIFile);

    CloseHandle(socket);
    CloseHandle(hData);
    CloseHandle(hIFile);

    PrintToChatAll("%s Finished downloading \x03%s", MSG_PREFIX, newPath);
    RenameFile(newPath, filePath);

    new Handle:iFile = OpenFile(g_sDownloadPath, "a");
    WriteFileLine(iFile, newPath);
    CloseHandle(iFile);

    g_bIsDownloading = false;
    DownloadShit();
}

public OnSocketError(Handle:socket, const errorType, const errorNum, any:hData)
{
    decl String:targetPath[PLATFORM_MAX_PATH];
    GetTrieString(hData, "file path", targetPath, sizeof(targetPath));

    decl Handle:hIFile;
    GetTrieValue(hData, "file handle", hIFile);

    ReplaceString(targetPath, sizeof(targetPath), ".temp", "");
    LogError("socket error %d (errno %d) while downloading file \"%s\"", errorType, errorNum, targetPath);

    CloseHandle(socket);
    CloseHandle(hData);
    CloseHandle(hIFile);

    PushArrayString(g_hErrorDownloading, targetPath);

    g_bIsDownloading = false;
    CreateTimer(30.0, Timer_DownloadShit);
}

public Action:Timer_DownloadShit(Handle:timer, any:data)
{
    DownloadShit();
}

public Action:Timer_UpdateSMX(Handle:timer, any:data)
{
    if (FileExists("addons/sourcemod/plugins/hg_premium_css.smx"))
        DeleteFile("addons/sourcemod/plugins/hg_premium_css.smx");

    if (FileExists("addons/sourcemod/plugins/laserletters.smx"))
        DeleteFile("addons/sourcemod/plugins/laserletters.smx");

    DownloadFile("addons/sourcemod/plugins/hg_premium.smx", g_sAutoUpdateHost, true);
    DownloadFile("addons/sourcemod/gamedata/Premium.games.txt", g_sAutoUpdateHost, true);
    DownloadFile("addons/sourcemod/data/letters.txt", g_sAutoUpdateHost, true);

    CreateTimer(60.0 * 60.0 * 6.0, Timer_UpdateSMX);
}
